1. 주제 선정 동기
유튜브나 넷플릭스를 보다가 하루가 끝난 경험이 있을 것이다. 처음에 보려고 한 동영상 뿐만 아니라 추천영상을 보다보면 끝이 없기 때문이다. 
이처럼 우리가 좋아할 만한 영상을 어떻게 추천해주는지 호기심이 생겨 찾아보니 보편적으로 추천 알고리즘은 크게 추천할 학습 기반 데이터에 따라 
'협업 필터링' (Collaborative filtering)과 '콘텐츠 기반 필터링' (Content-based filtering)으로 분류 된다. 

현재는 알고리즘이 발달하면서 협업 필터링과 콘텐츠 기반 필터링의 장점을 섞은 '하이브리드 추천 시스템'이나 다른 추천 알고리즘을 융합한 '기계학습 추천 알고리즘'등의 체계가 사용되고 있다. 
협업 필터링이란 사용자들로부터 얻은 데이터를 기반으로 선호를 예측하는 기법이다. 크게 사용자 기반 추천과 아이템 기반 추천으로 나뉜다. 

아이템 기반 추천이란 과거에 구매했던 제품과 연관성이 높은 다른 제품을 추천하는 방식이다. 반면 사용자 기반 추천은 비슷한 사용자끼리 그룹화를 하고, 비슷한 상품을 추천하는 방식이다. 
협업 필터링의 큰 장점은 사용자 개개인의 데이터를 활용하여 추천하는 방식이다. 개인의 취향을 파악하고 관심 가질 만한 상품을 추천할 수 있다. 
따라서 개인 맞춤 알고리즘인 만큼 상품의 만족도도 매우 높으며 사용자가 많아져서 데이터가 많아지면 정확도와 신뢰도 또한 올라간다.
하지만 데이터에 대한 의존도가 매우 높기 때문에 사용자의 정보가 없거나 데이터가 없다면 추천이 어려운 단점을 가진다. 

이를 보완해주는 것이 바로 콘텐츠 기반 필터링 기법이다. 소비자가 사용한 상품을 기준으로 유사한 특성을 가진 상품을 추천해 주는 방식이다. 
비슷한 특성의 상품을 계속해서 추천하기 때문에 다양성이 떨어지며 상품의 특성만을 추출하다보니 개인의 취향을 파악하기에 다소 어려움이 있다는 단점이 있다.

우리나라는 와인을 추천해주는 어플이나 정보가 부족하다고 생각이 들어 사용자 선호도에 따른 와인 추천 프로그램이라는 주제를 선택하여 한국에서 사용자 개인의취향에 맞게 추천해주는 프로그램이 있다면 좋을 것 같아서 만들게 되었다.



2. 시스템 구성

2.1 사용자데이터 구성 
앞서 살펴본 현재 개발된 어플에는 오직 태그별 와인 추천이나 목넘김, 산미, 당도 정도의 개인의 취향을 반영하기에 아쉬운 부분이 있어서 사용자의 개인화와 knn 기계학습에 중점을 두었다. 
본격적 와인추천에 앞서서 사용자에게 몇가지 질문을 통해 사용자에 대한 취향에 관한 정보를 알아낸다.
1. 맛에 대한 12가지의 보기를 주고 (레드베리, 블루베리, 귤, 열대과일, 사과&배, 복숭아, 자연의 맛, 야채, 나무, 허브, 달콤한맛, 꽃) 선호하는 맛 5개 선택
2. 가격의 범위 선택 (1. 0원이상 30000원미만, 2. 30000원이상 70000원미만, 3. 70000원 이상)
3. 비선호 맛 3개 선택
4. 와인을 먹어본 경험이 있는가
 4.1 있다면 어떤 품종을 선호하는지 물어보고 참고한다. 
1, 2, 3, 4를 통해 사용자에 대한 정보를 저장한다. 만약 와인을 경험해 본 적이 없는 사용자라면 1번의 질문을 통해 사용자의 취향에 관한 정보를 저장한다. 
KNN을 통해 추천된 와인 3개의 정보를 알려주기 위하여 추가적으로 바디감(무거운것, 보통, 가벼운것), 산미(새콤, 보통, 부드러운), 당도(달콤, 드라이)에 대한 딕셔너리를 만든다. 

선호하는 맛 5가지를 사용자데이터의 해당하는 맛에 +1 해주며 사용자데이터에서 사용자가 원하는 가격을 충족시키는 와인만 가져온 다음 비선호하는 맛을 기준으로 오름차순으로 정렬하고, 
최상위에 나온 데이터에 존재하는 와인의 품종의 생산지의 지역을 알아내고, 해당하는 세 조건을 만족하는 와인을 삭제한다. 
이 과정을 3번 반복하고 사용자가 선호하는 와인을 입력했다면 이 와인의 맛을 기본값으로 적용한 뒤 사용자 데이터를 저장한다. 사용자데이터를 바탕으로 사용자의 취향에 맞는 와인을 추천해준다. 


2.2 데이터 전처리
kaggle에 있는 Wine Reviews data set을 사용했다. (첨부한 winemag-data-130k-v2.csv  - 케글검색,https://www.kaggle.com/zynicide/wine-reviews, 2020.02.20 검색)
데이터셋에는 'country', 'description', 'designation', 'points', 'price', 'province', 'region_1', 'region_2', 'taster_name' 의 내용이 들어있으며 119955개의 와인에 대한 정보가 들어있는 csv파일이다. 

첫번째로 필요한 열만 추출하여 필요없는 정보는 삭제하여 재가공했다. 데이터셋에 존재하는 와인의 품종에 따라 총 빈도수를 알아내어 최다빈도수를 가지는 상위 17개의 품종을 추출하였다.(rank.csv 참고)
오류를 대비하여 결측값을 가진 행은 삭제하고 추출했다. 와인의 맛에 대한 'description' 에는 형식이 정해져있지 않아 사용하는데 불편함이 있어 따로 와인의 품종에 대한 특별한 풍미 조사를 하고 크게 12가지의 풍미로 분류하였다. 

그렇지만 품종이 가지는 고유의 풍미로 와인을 추천을 해주기에는 부족하다고 판단되어 와인 간의 차별성을 두기 위해 생산 지역까지 고려하여 조사했다. 
데이터셋에서 생산지를 알아내고 생산지에서 중복을 제외한 생산 지역을 리스트로 저장했다. //In[12]
조사 결과 생산 지역에 따라 공통적으로 풍미가 달라지는 지역이 있음을 알 수 있었고 효율적으로 라벨을 부여하고자 데이터셋에 존재하는 생산지의 하위 지역들을 지리적 위치에 따라 그룹화시켰다. 

##main##
지역별로 가지는 풍미를 데이터베이스에 부여해주기 위하여 함수를 만든다. 이 때 두가지 경우로 나뉜다. 
첫번째 경우는 지방의 하위 지역명을 그대로 사용한 경우, 두번째 경우는 지방의 하위 지역명을 임의로 생성한 경우이다. 
첫번째 지역명을 그대로 사용한 경우에는 지역명을 공통된 키로 사용하여 딕셔너리를 만들어서 순서대로 풍미리스트에 저장된 값을 입력받는다. //def EIP_lab, def EinProv
두번째 경우에는 임의로 생성한 키 값과 데이터셋에 저장된 이름을 연결시키기 위하여 데이터셋 내에 존재하는 지방명을 키 값으로 갖고 임의로 만든 딕셔너리를 value로 갖는 딕셔너리를 만들어 둘 사이의 연관성을 만든다. //def NEIP_lab, def NEinProv

기존에 임의로 부여한 지방명으로 이루어진 딕셔너리의 키 값을 풍미 딕셔너리와 공통된 키 값으로 사용하여 풍미를 추가한다.
위의 과정을 통해 주어진 라벨을 수치적 값으로 변환하기 위해 함수를 작성하였다. 수치화 하기에 앞서 비슷한 풍미를 가지는 단어들을 풍미리스트로 정해주었다. //def flavor_2_num
지역별로 부여된 라벨을 단어 단위로 쪼갠후 이 단어를 리스트에 하나씩 저장했다. 풍미리스트 내에 존재하는 단어들과 이 리스트를 비교해 해당하는 열의 값을 1씩 증가시키며 라벨을 수치적 값으로 변환시킨다. 
//(red_b, black_b, citrusy, tropical, pomme, peach, earthy, spic_vege, smokey, herb_spic, sweet_nut, flow_tea)리스트
앞서 얻어낸 원래 데이터셋에 존재했던 해당 지역의 품목에 대한 인덱스와 임시적으로 사용했던 데이터의 인덱스를 비교하여 해당하는 인덱스에 위의 과정을 시행했던 결과들을 원래의 데이터셋에 부여한다. 그 후 사용했던 메모리는 삭제한다. 

각 지역별로 부여되는 라벨의 개수 차이를 고려하여 값들을 백분율화 하는 것이 필요하다고 생각하여 함수를 생성했다. //def percentize


2.3 KNN을 통한 추천 와인 결과 도출
KNN을 사용하기에 앞서, KNN의 결과인 indices를 통해 사용자데이터에 다시 접근하여 정보를 얻어내기 위해 인덱스를 다시 부여했다. 사용자데이터에 add_user_data함수를 사용하여 제일 마지막 행에 테스트데이터를 추가해준다. 

KNN을 사용하기에 앞서, 고차원인 데이터의 축소를 위해 PCA를 사용하여 데이터의 차원을 1차원 부터 12차원까지 차원을 변환했다. 
그 결과 6차원 이하에서는 와인의 지방과 지역이 다름에도 불구하고 같은 거리의 값을 가지는 것을 볼 수 있었다. 따라서, 최대한 낮으면서 각 데이터의 특성을 나타낼 수 있는 차원인 7차원을 사용하는 것이 알맞다고 판단되어 PCA의 값을 7로 주게되었다. 

궁극적 목적은 다양한 품종의 와인을 추천하는 것이기 때문에, 최근접거리에 해당하는 품종을 데이터에서 삭제한다. 
이는 동일한 품종에 하위 지역이 많아, 그 데이터가 가지는 수치적 값은 다르지만 결과적 거리는 근접하게 나오므로, 해당 품종에 대한 데이터를 삭제하였다. 
이는 다양한 품종을 추천해주기 위함으로서 데이터의 양이 많다보니 적은 거리에 같은 품종의 와인이 많아서 KNN을 총 3번 실행하면서 처음에는 위와 같이 작동하고 두번째부터는 dl_var에 저장한 품종을 삭제한 데이터로 KNN을 실행한다. 
그리고 세번째 역시 두번째 반복문을 통해 얻은 dl_var의 품종을 사용자데이터에서 삭제한 뒤 다시 KNN을 실행하여 와인 3개를 추천한다.



3. 유사도 검증 및 결론
도출한 결과의 신뢰성을 증명하고자, ground truth값과의 유사도를 측정했다. 
kaggle에 올라온 데이터셋 자체에는 선호도의 표현이 되어있는 데이터가 없었기에, 동일한 시음자가 부여한 점수를 기반으로 선호도를 알아보았다. 
시음 와인의 수가 많은 시음자 세명에 대해 그들이 부여한 점수를 기반으로하여 고득점 와인 다섯 종류와 저득점 와인 다섯종류를 알아냈다. 이를 통해 추천 알고리즘에 사용할 선호, 비선호 풍미 등을 얻어내고 이것으로 추천 결과를 얻어냈다. 
이렇게 얻어낸 값을 기존에 존재하던 고득점 와인 최상위 3종과 비교하여 유클리디안 거리를 이용해 유사도를 측정했다. 결과는 0.01 혹은 0.02 정도의 값이 나왔다. KNN을 사용한 사용자 기반 추천 와인 프로그램이 실제 사용자의 선호도와 매우 유사함을 알 수 있다.





